Rank System Help
Ranks are assigned monthly based on activity among active users.
Active users are members with more than 0 monthly points.,
Your position among active users determines a candidate tier using percentile shares.,
You must also meet each tier's minimum points (and sometimes active days).,
If you don't meet the candidate tier requirements, you drop to the next tier.,
Users with 0 points or 0 active days are Unranked.,
Earning points
Minimum characters per message: 5,
Base points: message length / 30 (capped at 15 pts/msg),
Daily cap: up to 100 pts/day,
Bonuses: question '?' +2 pts, code block ``` +3 pts,
Anti-spam: very short/meaningless messages give 0 pts; at least 30s between scored messages.,
Inactivity decay
Points decay when inactive (tiered): 1-3 days: -0/day, 4-7 days: -10/day, 8-14 days: -25/day, 15-21 days: -50/day, 22-9999 days: -100/day
Tiers overview
 Challenger â€” Share: 1% | Min pts: 5000
 Grandmaster â€” Share: 2% | Min pts: 4000
 Master â€” Share: 3% | Min pts: 3000
 Diamond â€” Share: 4% | Min pts: 2000
 Emerald â€” Share: 5% | Min pts: 1500
 Platinum â€” Share: 10% | Min pts: 1000
 Gold â€” Share: 15% | Min pts: 750
 Silver â€” Share: 15% | Min pts: 500
 Bronze â€” Share: 20% | Min pts: 250
 Iron â€” Share: 25% | Min pts: 100
 Unranked â€” Share: - | Min pts: 0-99
Useful commands: !rank (leaderboard), !myrank (your rank), !ranks (tiers)

Strategy for Measuring Quality
The bot doesn't try to understand the meaning of a message (that would require complex AI). Instead, it uses a practical, rule-based strategy:

First, Filter Out "Noise": Immediately disqualify messages that are clearly not valuable contributions (too short, only symbols, etc.).
Then, Reward "Signal": Award a base amount of points for the raw effort of writing a longer message.
Finally, Add Quality Bonuses: Apply extra points (bonuses) for messages that exhibit specific, desirable traits like asking questions or sharing code.
Key Concepts in the Code
The logic is primarily contained in the calculate_message_points(self, content) method. Hereâ€™s how it works, step-by-step:

1. The Basic Requirement (The Filter)
A message must first pass these basic checks to earn any points.

Minimum Length: The message must be at least MIN_CHARS long (5 characters by default). This filters out one-word answers like "ok" or "thanks".
PYTHON
if len(content) < self.CONFIG['MIN_CHARS']:
    return 0
Meaningless Content: It uses regular expressions (re.match) to filter out messages that are just punctuation or symbols, which are likely not valuable.
PYTHON
if re.match(r"^[\s\.\,]+$", content): # Only spaces, dots, commas
    return 0
if re.match(r"^[^\w\?]{10,}$", content): # 10+ characters with no letters/numbers
    return 0
2. The Base Points (Rewarding Effort)
If a message passes the filter, it gets a base score based on its length.

Points per Character: It calculates len(content) / self.CONFIG['POINTS_PER_CHAR'] (e.g., a 150-character message would get 150 / 30 = 5 points).
Cap per Message: There's a cap (MAX_POINTS_PER_MSG) to prevent a single massive message from earning too many points at once (e.g., 15 points).
PYTHON
base_points = min(len(content) / self.CONFIG['POINTS_PER_CHAR'], 
                 self.CONFIG['MAX_POINTS_PER_MSG'])
3. The Quality Bonuses (Rewarding Specific Value)
This is the most direct answer to your "how do you measure quality?" question. The system looks for specific, high-value patterns and adds bonus points.

Question Bonus (?): Adds a bonus if the message contains a question mark. This encourages helping and engaging others.
PYTHON
if '?' in content:
    bonuses += self.CONFIG['QUALITY_BONUSES']['question'] # e.g., +2 points
Code Block Bonus (```): Adds a larger bonus if the message contains a code block (marked with triple backticks). This encourages sharing solutions and code, which is highly valuable in a programming server.
PYTHON
if '```' in content:
    bonuses += self.CONFIG['QUALITY_BONUSES']['code_block'] # e.g., +3 points
4. Advanced: AI-Powered Anti-Cheat (The Future-Proofing)
The code also shows a more advanced, optional integration with an "AntiCheat" module. This is a separate cog designed to use AI to detect truly low-quality or "meaningless" messages that passed the basic rule-based filters.

How it works: For longer messages (>20 chars), it waits a moment for the AntiCheat cog to analyze the message.
The Signal: If the AntiCheat cog finds the message meaningless, it adds a ðŸš« reaction to it.
The Action: The activity tracker sees this reaction and does not award any points for that message, even if it's long and has bonuses.
PYTHON
# ... inside on_message, after basic checks ...
if len(message.content) > 20 and anti_cheat_cog:
    await asyncio.sleep(0.5) # Wait for AI to process
    message = await message.channel.fetch_message(message.id) # Refresh to get reactions
    for reaction in message.reactions:
        if reaction.emoji == 'ðŸš«' and reaction.count > 0: # If flagged as meaningless
            logger.info(f"Message flagged as meaningless, skipping points")
            return # Exit without giving points
Summary of Quality Determination
In order of priority:

Is it long enough and not just symbols? (No -> 0 points)
Is it flagged as meaningless by AI? (Yes -> 0 points)
Give base points for effort (length).
Add bonus points for high-value traits (questions, code blocks).
